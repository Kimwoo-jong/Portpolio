메인화면
뒷 배경 사이즈 : 1.26, 1.26
Back : -8.85, 0, 0
Back1 : -35.45, 0, 0
Front : -7.05, 0, 0
Front1 : -31.7, 0, 0

뒷 배경 움직임은 부모 오브젝트 Background가 이동을 한다.

여러 해상도에서 일관성 있게 UI크기를 유지하려면
캔버스의 크기는 640 * 360 >> 가로의 크기에 따라 UI 크기 조절을 한다.

메인메뉴에서 새가 랜덤으로 2~4마리가 날아감.

새가 끝까지 날아가면 다시 재활용 하기 위하여 오브젝트풀링 사용 (BirdBox)를 부모 오브젝트로 함.
========================================================================

메인 화면의 게임 시작, 설정, 종료 버튼 >> 기능 연결 완료

설정 창의 UI 적당하게 배치 후 게임 씬 작업 시작 (사운드 관련은 추후 작업 진행 예정)

Dungreed Demo 버전을 참고하여 튜토리얼 맵 제작 시작

타일맵의 콜라이더는 Composite Collider를 활용하여 합쳐주고, RigidBody를 Static으로 하여 움직이지 않게 고정.

합치면서 바닥의 콜라이더가 원하는 곳보다 밑에 있으므로, 새로운 콜라이더 오브젝트 2개를 만들어 맵의 우측 벽과 바닥에 만든 후, 동일하게 Composite Collider 추가

Canvas를 활용하여 맵의 바닥 어두운 부분에 튜토리얼용 키보드 이미지 추가
(canvas Render Mode WorldSpace를 이용하여 UI를 맵의 한 부분으로 설정)

플레이어 간단한 이동 및 점프 구현

카메라가 플레이어를 따라다니도록 하고, 맵의 바깥을 비추지 않도록 구현

플레이어 애니메이션 생성 - 애니메이션 연동 확인
========================================================================

타일맵 Composite 콜라이더를 어떻게 해야할 지 고민

실제 게임을 플레이 해보니 초반맵에 오르막길은 오를 필요가 없었다..
(콜라이더 트리거로 변경.)
(타일맵 콜라이더를 활용하지 않고 개별 콜라이더를 만들어 적용할 예정)

그라운드 체크는 Layer로 트리거, 콜라이더 체크는 태그로 하는 방식으로 활용함.

던전 입구 리소스 추출 
>> 트리거에 닿을 시 애니메이션 실행과 함께 Player 비활성화 및 다음 씬 로드

점프가 다시 두 번되서 코드 수정
========================================================================

플레이어 이동 및 점프할 때 먼지 이펙트가 나오도록 구현 예정
>> 파티클 이펙트 사용

플레이어가 통과하면서 밟을 수도 있는 플랫폼
>> Platform Effector라는 것이 있었음.
>> 원하는 방향은 트리거처럼 통과되게 하고 아닌 방향으로는 콜라이더 취급

경사로 오를 수 있게 하는 코드 구현중
>> 슬로프와 플레이어 사이의 벡터값으로 계산하는 것이 어려웠다.
>> 수학적인 부분이 들어가는 부분에서 시간 소요가 좀 있다. (보완할 점)
        

//나아가려는 힘 = ( 질량 * 중력 * Sin(세타) )
float pushForce = playerMass * playerGravity;
//마찰력 = ( 마찰계수 * 질량 * 중력 * Cos(세타) )
float frictionForce = playerFriction * playerMass * playerGravity;

하나의 코드에 모든 기능이 구현되니 코드가 지저분해보임.
>> 모듈화 실행
>> 플레이어의 이동, 점프를 담당하는 PlayerController
>> 플레이어의 물리 시뮬레이션을 담당하는 PlayerPhysics
>> 차후 추가되는 부분이 있을 시 추가할 예정

========================================================================

경사로에서 미끄러지지 않게 하는 부분 구현이 어려움.
>> 키보드의 입력이 없을 때
>> rigidbody의 constraints에서 Freeze Position X를 해주고 입력이 있을 시는 꺼주도록 해결

무기를 들고 공격하는 모션과 마우스 위치를 바라보는 플레이어까지 구현 예정(3/3에 못함)

========================================================================

플레이어의 머리가 경사면 보다 위에 있을 때 경사를 오를 수가 없음.
>>플레이어의 하체 쪽에서 레이를 쏴주는 것으로 변경

마우스 커서 인게임에서 바뀌도록 스크립트 작성

플레이어 기준 마우스가 우측일 때
>> 무기를 들고 공격하는 모션과 마우스 위치를 바라보는 플레이어까지 구현 예정
>> 무기 휘두르는 모션 >> 애니메이션으로 Rotation을 줌.
>> 마우스 위치 바라보도록 스크립트 작성 완료
>> 무기와 캐릭터 자연스럽게 위치 바뀜.
>> 칼 공격 애니메이션 위 >> 아래, 아래 >> 위 두개로 두고 Integer값에 따라 번갈아 실행되도록 구현
검기 효과 구현 시작 (미구현)

========================================================================
(깃허브 사용법 익히는 날)

Git hub Repository에 프로젝트 파일 업로드 실행

>> 유니티 에디터의 버전을 동일하게 해야함.
>> 애셋 직렬화 방식 : 텍스트로 통일 > Edit project setting >> Editor Asset Serialization Force Text
>> meta 파일 생성 파괴 패턴
>> 프로젝트 뷰가 아닌 방법으로 파일을 이동시키거나 이름 변경 (missing component가 뜸)
>> 그 파일의 이름으로 된 meta 파일이 없을 경우 다시 만든다.
>> meta 파일의 원본이 없는 경우
>> 파일 덮어쓰기 외에는 프로젝트 뷰에서 파일을 조작하는 것이 기본
>> 어쩔 수 없이 보내야 할 경우 메타파일을 같이 보내거나, 패키지화해서 보내야 함.

>> meta 파일이 갱신 시점되고 저장되는 시점은 씬을 저장하거나, 프로젝트를 저장하는 경우
>> meta 파일을 유지한 채로 파일을 바꾸고 싶으면 탐색기를 통해서 덮어쓰기를 한다.

========================================================================

플레이어 One-Way Platform 구현
>> Composite collider를 이용하여 하는 것은 할 수 있는지 없는지를 잘 모르겠어서
>> 위의 사안은 정보를 더 찾아봐야할 듯 하다.
>> Box collider 하나를 쭉 길게 늘린 뒤에 Effector를 사용하도록 하여
>> 아래 점프 구현 완료

적 간단한 애니메이션 구현 및 플레이어 UI 제작 시작

========================================================================

플레이어 베기 이펙트 >> 애니메이션이 실행되면서 Instantiate 해주고 Destroy하는 방식으로 구현
>>공격은 자주 사용하므로, 오브젝트 풀링을 사용해도 좋을 것 같다.

플레이어 UI >> 플레이어 자식 객체로 캔버스를 넣었음.
기존에 사용하던 PlayerStatus 스크립트는 능력치 위주로 사용하기 위해 Health스크립트 따로 만듦
>> 슬라이더와 텍스트를 연결하여 데미지가 달면 변경되도록 구현

점프 시 먼지 이펙트 구현

적 오브젝트가 플레이어 추적하는 기능 구현 시작
A* 알고리즘을 활용해야 하는데 적용 방법을 찾는데 시간이 많이 소요될 것 같다.
>> 내일 진행 예정

던전 입구 트리거 >> 닿은 위치에 문이 생성되도록 구현

========================================================================

인벤토리 시스템 구현 시작
>> 스크립터블 오브젝트 사용 : 유니티에서 제공하는 대량의 데이터를 저장하는데 사용할 수 있는 데이터 컨테이너.

InventoryManager의 ListItems()
>>위 함수를 인벤토리가 켜지거나 꺼질 때 실행되게 하면 중복 생성되는 문제가 발생함
>>해당 위치의 오브젝트를 파괴하는 식으로 스크립트를 추가하니 중복 생성은 되지 않음.
>>하지만, 인벤토리를 켜둔 채로 먹게 되면 아이템이 슬롯에 들어오지 않아서
>>플레이어의 버튼 조작과는 상관없이 항상 리스트업 되도록 설정해주니 정상적으로 작동한다.

>>현재의 인벤토리는 아이템을 습득하면 아이템 슬롯이 생성되는 것으로 구현이 되어있음.
>>이를 발전시켜 기존에 있는 슬롯에 해당 아이템의 정보가 들어가도록 변경해야 함.

아이템 습득 시 정보가 인벤토리로 이동되고, 마우스를 올렸을 시 툴팁 나오는 기능까지 구현

추가 사항으로는
인벤토리 내에서 아이템끼리의 Swap과 우클릭으로 장착 및 해제
>> 장착 및 해제를 통한 플레이어 무기 오브젝트 이미지 및 데미지 변화 등을 구현할 예정

DraggableItem, DroppableItem, ClickableItem 스크립트 생성 예정
(각각 드래그 드롭 클릭을 담당한다)

아이템의 정보를 얻어올 수 없는 부작용이 생겨서, 스크립트 전체적으로 다시 구현함.
Onvalidate() 사용
>> OnValidate는 스크립트 또는 인스펙터 상에서 변수의 값이 변경될 때 호출되는 함수이다.
>> Editor 단계의 이벤트 함수이므로 플레이 모드가 아닐 때 호출된다.

Action<> 델리게이트 사용(사용시 using System;을 해야함)
>> 반환값이 없는 메서드를 참조하는 델리게이트 변수이다.
>> 매개변수를 0~16개 가질 수 있는 값을 반환하지 않는 메서드를 캡슐화

========================================================================

아이템 장착시 스탯의 변화가 있기 때문에
>> 스탯 구현 관련 영상을 참고하여 구현 시작
>> 스탯의 구현이 끝나면 다시 인벤토리로 돌아가서 작업 진행 예정

readonly 사용
>> 런타임 상수이다. (exe 또는 dll을 사용할 때 변수의 값을 가져온다.)
>> 모든 자료형에 사용 할 수 있으며, 생성과 동시에 초기화 할 필요는 없다.
>> 단, 생성자 단계에서 단 1번 할당을 통해 초기화 할 수 있다. 
>> 메모리 할당 위치는 Heap Memory이다.
>> readonly는 생성시 선언하지 않아도, 생성자에서 초기화 하여 사용 할 수 있기 때문에 유연하며, 실제 사용    하는 단계에서 변수의 값을 가져오는 장점이 존재한다.
>> 상수값 변경시 재 컴파일을 하지 않고, 사용하는 생성자 단에서 변수에 값을 할당해서 사용 할 수 있다.
     고로 const 보다는 readonly의 사용을 좀 더 고려해볼 필요가 있다.

스탯을 계산하게 되면 여러가지 요소가 적용이 되는데
합연산을 우선적으로 시행하고 곱연산이 들어가도록 구현해보자.
ex) 기본 : 10, 아이템 : 10, 스탯 + 10%
>> 10 * 1.1 + 10으로 하면 아이템을 착용했을 시 더해지는 수치가 스탯값에 따라 조절이 되지 않기에
>> ( 10 + 10 ) * 1.1로 연산을 하도록

스탯을 적용했더니 마우스 우클릭 장착이 되지 않는다.
>> 문제 찾아보는 중 (문제를 찾기 못하여 처음부터 다시 작성하였다.)
>> 슬롯 체인지 기능은 인벤토리 기능 끝나고 구현 예정

문제 해결 후 툴팁 기능 구현
>> StringBuilder 사용 (using system.text;)
>> String의 문자열을 변경하면 계속 새로운 String을 만들어 내기 때문에 성능 저하가 일어날 수 있다.
>> StringBuilder라는 변경 가능한 문자열 클래스를 사용한다.

툴팁을 구현했는데 원하는 모습으로 나오지 않아 정보 검색
>> Flexible Grid Layout이라는 것을 찾음.
>> 스크립트를 만들고, LayoutGroup을 상속
>> Flexible Grid Layout 구현은 아직 하지 못함.

ToolTip UI를 새로 만들어서 구현하였음
>> 텍스트가 넘치면 자동으로 크기가 커지는 것 구현할 예정

========================================================================

컴퓨터를 껐다가 키고 나면, 우클릭 장착이 되지 않는다. 이유를 모르겠음.
>> OnValidate에서만 함수 동작을 하게 둔 것이 원인이었다.

스탯 툴팁 작업 시작
>> 작업 완료 후 버그를 픽스할 예정
>> 마우스 우클릭 메소드가 Awake에서 실행되게 되면 안되는 경우가 생김.
>> Start로 실행하게 한 후 자잘한 버그 수정을 위하여 Init 속성을 사용
>> 스탯의 설명과 이름의 출력이 원활하지 못함. 코드를 더 보면서 공부해야 할 듯

Init() 속성이란
>> 초기에 한 번 설정이 되면, 그 이후에는 변경할 수 없는 기능이다.
>> Init을 public으로 선언해준 뒤 매니저 속성을 띄는 Character.cs의 Awake에서 실행되도록 연결
>> 더 간단한 방법을 RefreshUI()함수를 Inventory.cs의 OnValidate에서만 호출하는 것이 아닌 Start에서도 호출하는 것이 더 좋다.

아이템의 드래그 n 드롭 기능 구현

[FormerlySerializedAs("")] 사용
>> 유니티를 이용해 작업하다 보면 데이터를 저장하기 위해 SerializedField와 같은 어트리뷰트를 사용한다.
>> 문제는 개발 도중 이 필드의 이름이 변경되어 기존 저장된 데이터들을 사용하지 못하게 되는 경우가 있다. >> 이 경우 FormerlySerializedAs 어트리뷰트를 이용해 기존 버전과의 호환성을 유지해 줄 수 있다.

>> 스탯 툴팁에서 변경된 값과 이름은 출력 성공
>> 각 스탯의 설명만 추가하면 구현 완료.

========================================================================

박스에서 아이템이 랜덤으로 드롭되는 기능 구현 예정

AssetDatabase 사용
using UnityEditor

>> Unity Editor상에서 모든 에셋 관련 파일 처리를 할때 사용하는 클래스로 기본 파일 입출력부터 Material,      Prefab, Animationclip, CustomAsset등 파일을 만들고 제어 할 수 있습니다.
>> 응용으로 프로젝트 내의 모든 씬파일을 찾아서 수정을 하거나, 현재 씬에 존재하는 오브젝트들을 자동으로      프리팹으로 만들어주는 기능을 만들 수 있습니다.
>> 주의할 점은 AssetDatabase클래스는 Editor상에서만 동작하며 해당 코드를 사용하는 부분은 		     #if UNITY_EDITOR 조건 컴파일을 걸어야 빌드할 때 에러나지 않습니다.

아이템을 인벤토리 바깥에 드롭하면 제거되는 기능 구현
>> UI로 가려지지 않는 부분을 DropArea로 설정하여 아이템을 드롭하면 파괴 메시지가 뜨며 사라지도록 구현

========================================================================

게임을 껐다 켰을 때 인벤토리에 아이템이 그대로 있도록
Save기능 구현

GetcomponentsInChildern(includeInactive : true, result : itemSlots);
>> GetComponentsInChildren<T>()는 숨겨진 파라미터 includeInactive가 들어있으며, 기본값이 false입니다
여기에 인자로 bool값 true를 넣어주면 activeSelf가 꺼져있는 자식 오브젝트들도 전부 가져올 수 있습니다

아이템 드롭 시 파괴되는 기능을 구현했더니 슬롯 체인지가 되지 않음을 발견
>> Save기능 구현 완료 후 수정 예정

슬롯 체인지 기능 수정 완료

장비 착용 후 게임을 껐을 때 에디터에서 Save가 되어 재실행 했을 때 인벤토리에 반영이 되지 않은 이유
>> InventoryPanel이 꺼져있어서 갱신이 되지 않았음.
>> 체크를 위해 인벤토리 패널을 켜서 확인한 결과 정상적으로 실행이 됨.

스탯 툴팁의 스탯 설명 부분 추가 예정
>> 스탯 패널 설명 부분 추가 완료

>> 툴팁 패널 오류 수정(진행중)
>> 툴팁 패널 수정 및 정상 작동 확인 후 보스 패턴 작업 예정
========================================================================

박스와 상호작용 시 아이템 랜덤 드롭되는 기능 구현 예정
>> 아이템 랜덤 드롭 및 상자 sprite 변환
>> 생성된 아이템에 각각 아이템에 맞는 정보가 들어감
>> ImageController라는 스크립트를 만들어서 박스 오브젝트 위에 이미지가 플로팅 되어있도록 함
>> 이미지는 플레이어가 접근했을 때 활성화 되고 아닐 시 비활성화 됨.

>> Resize 스크립트를 만들어
>> 박스콜라이더의 크기 = 월드에 그려진 스프라이트의 사이즈로 해주어
>> 콜라이더의 크기가 이미지에 따라 다르게 변경되도록

>> 아이템 생성 시에 위치가 겹치기 때문에 수정해야 함.
>> 아이템과 충돌 시에 인벤토리에 들어가도록 구현 예정

>> 인벤토리에 들어가도록 구현 완료.

========================================================================

>> Resize 스크립트로 사용시 이미지가 바닥에서 붕 뜨기 때문에
>> 임의적으로 사이즈를 정해준 뒤 바꾸도록 변경

>> 아이템이 드롭될 시 퍼지면서 드롭되도록 수정
>> Random.insideUnitCircle.normalized
>> 원호의 랜덤 지점을 얻어낸다.

>> 아이템 드롭 구현 완료

========================================================================

vscode로 사용툴 변경

Enemy AI 기능 구현 구상
>> A* 알고리즘을 활용하여 플레이어를 추적할 수 있도록 할 것.
>> 단방향 플랫폼 기능을 활용하였으므로, 이를 인식할 수 있어야 함.

단방향 플랫폼을 아래방향에서 통과할 경우
>> 통과할 수 있는 오브젝트로 인식하고, 위에 있는 경우에는 걸어다닐 수 있는 바닥으로 인식해야 함.

타일맵을 여러개 둔다.
>> Background용, 콜라이더 체크용 타일맵 등을 만든다.

Node 스크립트
>> 노드에서 사용할 변수들을 정의하는 클래스

Grid2D 스크립트
>> 그리드를 만들어준다 (크기는 내가 설정할 수 있음)
>> 월드 내의 좌표를 노드의 위치로 바꾸어준다.
>> OnDrawGizmos를 활용하여 씬 뷰에서 작동이 잘 되는지 확인 가능
>> Display Grid Gizmos를 True할 경우 그리드 기즈모가 씬뷰 상에 보이게 됨.(경로 확인 용)
>> TileType을 추가하여 레이어마스크에 따라 이동 가중치를 다르게 둔다.

PathFinding 스크립트
>> 시작점부터 목적지까지의 경로를 계산하는 함수들이 담겨있음.
>> using System.Dianostics ( Debug 관련 API )
>> 위 스크립트에서는 스톱워치 기능을 이용한 패스파인딩 함수 실행 시간을 보기 위해 사용

PathRequestManager 스크립트
>> PathFinding과 관련된 작업들을 통합적으로 관리해주는 스크립트
>> 경로 탐색 요청, 경로 탐색 중인지 확인, 완료되었을 경우 다음 경로 요청 처리를 한다.\

Unit 스크립트
>> 위의 스크립트에서 진행한 작업을 토대로 해당 위치까지 경로 탐색을 하여 이동할 오브젝트를 관리
>> PathFinding 클래스에서 경로를 찾은 뒤 유닛이 해당 경로를 받도록 한다.
>> RequestPath 함수를 호출하여 유닛과 플레이어 간의 경로를 찾도록 요청
>> 경로가 있다면 OnPathFound함수를 통해 코루틴 함수를 실행한다.
>> 코루틴을 사용해 경로의 다음 위치가 있으면 계속 이동하도록 함.
>> 플레이어를 감지할 수 있는 트리거를 설치해 Stay하는 동안 경로가 갱신되도록 한다.

경로 탐색 알고리즘 구현은 된 듯함.