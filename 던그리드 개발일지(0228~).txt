2/28
메인화면
뒷 배경 사이즈 : 1.26, 1.26
Back : -8.85, 0, 0
Back1 : -35.45, 0, 0
Front : -7.05, 0, 0
Front1 : -31.7, 0, 0

뒷 배경 움직임은 부모 오브젝트 Background가 이동을 한다.

여러 해상도에서 일관성 있게 UI크기를 유지하려면
캔버스의 크기는 640 * 360 >> 가로의 크기에 따라 UI 크기 조절을 한다.

메인메뉴에서 새가 랜덤으로 2~4마리가 날아감.

새가 끝까지 날아가면 다시 재활용 하기 위하여 오브젝트풀링 사용 (BirdBox)를 부모 오브젝트로 함.
========================================================================
3/1
메인 화면의 게임 시작, 설정, 종료 버튼 >> 기능 연결 완료

설정 창의 UI 적당하게 배치 후 게임 씬 작업 시작 (사운드 관련은 추후 작업 진행 예정)

Dungreed Demo 버전을 참고하여 튜토리얼 맵 제작 시작

타일맵의 콜라이더는 Composite Collider를 활용하여 합쳐주고, RigidBody를 Static으로 하여 움직이지 않게 고정.

합치면서 바닥의 콜라이더가 원하는 곳보다 밑에 있으므로, 새로운 콜라이더 오브젝트 2개를 만들어 맵의 우측 벽과 바닥에 만든 후, 동일하게 Composite Collider 추가

Canvas를 활용하여 맵의 바닥 어두운 부분에 튜토리얼용 키보드 이미지 추가
(canvas Render Mode WorldSpace를 이용하여 UI를 맵의 한 부분으로 설정)

플레이어 간단한 이동 및 점프 구현

카메라가 플레이어를 따라다니도록 하고, 맵의 바깥을 비추지 않도록 구현

플레이어 애니메이션 생성 - 애니메이션 연동 확인
========================================================================
3/2

타일맵 Composite 콜라이더를 어떻게 해야할 지 고민

실제 게임을 플레이 해보니 초반맵에 오르막길은 오를 필요가 없었다..
(콜라이더 트리거로 변경.)
(타일맵 콜라이더를 활용하지 않고 개별 콜라이더를 만들어 적용할 예정)

그라운드 체크는 Layer로 트리거, 콜라이더 체크는 태그로 하는 방식으로 활용함.

던전 입구 리소스 추출 
>> 트리거에 닿을 시 애니메이션 실행과 함께 Player 비활성화 및 다음 씬 로드

점프가 다시 두 번되서 코드 수정
========================================================================
3/3

플레이어 이동 및 점프할 때 먼지 이펙트가 나오도록 구현 예정
>> 파티클 이펙트 사용

플레이어가 통과하면서 밟을 수도 있는 플랫폼
>> Platform Effector라는 것이 있었음.
>> 원하는 방향은 트리거처럼 통과되게 하고 아닌 방향으로는 콜라이더 취급

경사로 오를 수 있게 하는 코드 구현중
>> 슬로프와 플레이어 사이의 벡터값으로 계산하는 것이 어려웠다.
>> 수학적인 부분이 들어가는 부분에서 시간 소요가 좀 있다. (보완할 점)
        

//나아가려는 힘 = ( 질량 * 중력 * Sin(세타) )
float pushForce = playerMass * playerGravity;
//마찰력 = ( 마찰계수 * 질량 * 중력 * Cos(세타) )
float frictionForce = playerFriction * playerMass * playerGravity;

하나의 코드에 모든 기능이 구현되니 코드가 지저분해보임.
>> 모듈화 실행
>> 플레이어의 이동, 점프를 담당하는 PlayerController
>> 플레이어의 물리 시뮬레이션을 담당하는 PlayerPhysics
>> 차후 추가되는 부분이 있을 시 추가할 예정

========================================================================
3/5
경사로에서 미끄러지지 않게 하는 부분 구현이 어려움.
>> 키보드의 입력이 없을 때
>> rigidbody의 constraints에서 Freeze Position X를 해주고 입력이 있을 시는 꺼주도록 해결

무기를 들고 공격하는 모션과 마우스 위치를 바라보는 플레이어까지 구현 예정(3/3에 못함)

========================================================================
3/7

플레이어의 머리가 경사면 보다 위에 있을 때 경사를 오를 수가 없음.
>>플레이어의 하체 쪽에서 레이를 쏴주는 것으로 변경

마우스 커서 인게임에서 바뀌도록 스크립트 작성

플레이어 기준 마우스가 우측일 때
>> 무기를 들고 공격하는 모션과 마우스 위치를 바라보는 플레이어까지 구현 예정
>> 무기 휘두르는 모션 >> 애니메이션으로 Rotation을 줌.
>> 마우스 위치 바라보도록 스크립트 작성 완료
>> 무기와 캐릭터 자연스럽게 위치 바뀜.
>> 칼 공격 애니메이션 위 >> 아래, 아래 >> 위 두개로 두고 Integer값에 따라 번갈아 실행되도록 구현
검기 효과 구현 시작 (미구현)

========================================================================
3/8 (깃허브 사용법 익히는 날)

Git hub Repository에 프로젝트 파일 업로드 실행

>> 유니티 에디터의 버전을 동일하게 해야함.
>> 애셋 직렬화 방식 : 텍스트로 통일 > Edit project setting >> Editor Asset Serialization Force Text
>> meta 파일 생성 파괴 패턴
>> 프로젝트 뷰가 아닌 방법으로 파일을 이동시키거나 이름 변경 (missing component가 뜸)
>> 그 파일의 이름으로 된 meta 파일이 없을 경우 다시 만든다.
>> meta 파일의 원본이 없는 경우
>> 파일 덮어쓰기 외에는 프로젝트 뷰에서 파일을 조작하는 것이 기본
>> 어쩔 수 없이 보내야 할 경우 메타파일을 같이 보내거나, 패키지화해서 보내야 함.

>> meta 파일이 갱신 시점되고 저장되는 시점은 씬을 저장하거나, 프로젝트를 저장하는 경우
>> meta 파일을 유지한 채로 파일을 바꾸고 싶으면 탐색기를 통해서 덮어쓰기를 한다.

========================================================================
3/9

플레이어 One-Way Platform 구현
>> Composite collider를 이용하여 하는 것은 할 수 있는지 없는지를 잘 모르겠어서
>> 위의 사안은 정보를 더 찾아봐야할 듯 하다.
>> Box collider 하나를 쭉 길게 늘린 뒤에 Effector를 사용하도록 하여
>> 아래 점프 구현 완료

적 간단한 애니메이션 구현 및 플레이어 UI 제작 시작

========================================================================
3/12

플레이어 베기 이펙트 >> 애니메이션이 실행되면서 Instantiate 해주고 Destroy하는 방식으로 구현
>>공격은 자주 사용하므로, 오브젝트 풀링을 사용해도 좋을 것 같다.

플레이어 UI >> 플레이어 자식 객체로 캔버스를 넣었음.
기존에 사용하던 PlayerStatus 스크립트는 능력치 위주로 사용하기 위해 Health스크립트 따로 만듦
>> 슬라이더와 텍스트를 연결하여 데미지가 달면 변경되도록 구현

점프 시 먼지 이펙트 구현

적 오브젝트가 플레이어 추적하는 기능 구현 시작
A* 알고리즘을 활용해야 하는데 적용 방법을 찾는데 시간이 많이 소요될 것 같다.
>> 내일 진행 예정

던전 입구 트리거 >> 닿은 위치에 문이 생성되도록 구현

========================================================================
3/14 (예비군 훈련)

========================================================================
3/15

인벤토리 시스템 구현 시작
>> 스크립터블 오브젝트 사용 : 유니티에서 제공하는 대량의 데이터를 저장하는데 사용할 수 있는 데이터 컨테이너.

InventoryManager의 ListItems()
>>위 함수를 인벤토리가 켜지거나 꺼질 때 실행되게 하면 중복 생성되는 문제가 발생함
>>해당 위치의 오브젝트를 파괴하는 식으로 스크립트를 추가하니 중복 생성은 되지 않음.
>>하지만, 인벤토리를 켜둔 채로 먹게 되면 아이템이 슬롯에 들어오지 않아서
>>플레이어의 버튼 조작과는 상관없이 항상 리스트업 되도록 설정해주니 정상적으로 작동한다.

>>현재의 인벤토리는 아이템을 습득하면 아이템 슬롯이 생성되는 것으로 구현이 되어있음.
>>이를 발전시켜 기존에 있는 슬롯에 해당 아이템의 정보가 들어가도록 변경해야 함.

아이템 습득 시 정보가 인벤토리로 이동되고, 마우스를 올렸을 시 툴팁 나오는 기능까지 구현

추가 사항으로는
인벤토리 내에서 아이템끼리의 Swap과 우클릭으로 장착 및 해제
>> 장착 및 해제를 통한 플레이어 무기 오브젝트 이미지 및 데미지 변화 등을 구현할 예정

DraggableItem, DroppableItem, ClickableItem 스크립트 생성 예정
(각각 드래그 드롭 클릭을 담당한다)

아이템의 정보를 얻어올 수 없는 부작용이 생겨서, 스크립트 전체적으로 다시 구현함.
Onvalidate() 사용
>> OnValidate는 스크립트 또는 인스펙터 상에서 변수의 값이 변경될 때 호출되는 함수이다.
>> Editor 단계의 이벤트 함수이므로 플레이 모드가 아닐 때 호출된다.

Action<> 델리게이트 사용(사용시 using System;을 해야함)
>> 반환값이 없는 메서드를 참조하는 델리게이트 변수이다.
>> 매개변수를 0~16개 가질 수 있는 값을 반환하지 않는 메서드를 캡슐화

========================================================================
3/16

아이템 장착시 스탯의 변화가 있기 때문에
>> 스탯 구현 관련 영상을 참고하여 구현 시작
>> 스탯의 구현이 끝나면 다시 인벤토리로 돌아가서 작업 진행 예정

readonly 사용
>> 런타임 상수이다. (exe 또는 dll을 사용할 때 변수의 값을 가져온다.)
>> 모든 자료형에 사용 할 수 있으며, 생성과 동시에 초기화 할 필요는 없다.
>> 단, 생성자 단계에서 단 1번 할당을 통해 초기화 할 수 있다. 
>> 메모리 할당 위치는 Heap Memory이다.
>> readonly는 생성시 선언하지 않아도, 생성자에서 초기화 하여 사용 할 수 있기 때문에 유연하며, 실제 사용    하는 단계에서 변수의 값을 가져오는 장점이 존재한다.
>> 상수값 변경시 재 컴파일을 하지 않고, 사용하는 생성자 단에서 변수에 값을 할당해서 사용 할 수 있다.
     고로 const 보다는 readonly의 사용을 좀 더 고려해볼 필요가 있다.

스탯을 계산하게 되면 여러가지 요소가 적용이 되는데
합연산을 우선적으로 시행하고 곱연산이 들어가도록 구현해보자.
ex) 기본 : 10, 아이템 : 10, 스탯 + 10%
>> 10 * 1.1 + 10으로 하면 아이템을 착용했을 시 더해지는 수치가 스탯값에 따라 조절이 되지 않기에
>> ( 10 + 10 ) * 1.1로 연산을 하도록

스탯을 적용했더니 마우스 우클릭 장착이 되지 않는다.
>> 문제 찾아보는 중 (문제를 찾기 못하여 처음부터 다시 작성하였다.)
>> 슬롯 체인지 기능은 인벤토리 기능 끝나고 구현 예정

문제 해결 후 툴팁 기능 구현
>> StringBuilder 사용 (using system.text;)
>> String의 문자열을 변경하면 계속 새로운 String을 만들어 내기 때문에 성능 저하가 일어날 수 있다.
>> StringBuilder라는 변경 가능한 문자열 클래스를 사용한다.

툴팁을 구현했는데 원하는 모습으로 나오지 않아 정보 검색
>> Flexible Grid Layout이라는 것을 찾음.
>> 스크립트를 만들고, LayoutGroup을 상속
>> Flexible Grid Layout 구현은 아직 하지 못함.

ToolTip UI를 새로 만들어서 구현하였음
>> 텍스트가 넘치면 자동으로 크기가 커지는 것 구현할 예정

========================================================================
3/17 (작계 훈련)

========================================================================
3/19

컴퓨터를 껐다가 키고 나면, 우클릭 장착이 되지 않는다. 이유를 모르겠음.
>> OnValidate에서만 함수 동작을 하게 둔 것이 원인이었다.

스탯 툴팁 작업 시작
>> 작업 완료 후 버그를 픽스할 예정
>> 마우스 우클릭 메소드가 Awake에서 실행되게 되면 안되는 경우가 생김.
>> Start로 실행하게 한 후 자잘한 버그 수정을 위하여 Init 속성을 사용
>> 스탯의 설명과 이름의 출력이 원활하지 못함. 코드를 더 보면서 공부해야 할 듯

Init() 속성이란
>> 초기에 한 번 설정이 되면, 그 이후에는 변경할 수 없는 기능이다.
>> Init을 public으로 선언해준 뒤 매니저 속성을 띄는 Character.cs의 Awake에서 실행되도록 연결
>> 더 간단한 방법을 RefreshUI()함수를 Inventory.cs의 OnValidate에서만 호출하는 것이 아닌 Start에서도 호출하는 것이 더 좋다.

아이템의 드래그 n 드롭 기능 구현

[FormerlySerializedAs("")] 사용
>> 유니티를 이용해 작업하다 보면 데이터를 저장하기 위해 SerializedField와 같은 어트리뷰트를 사용한다.
>> 문제는 개발 도중 이 필드의 이름이 변경되어 기존 저장된 데이터들을 사용하지 못하게 되는 경우가 있다. >> 이 경우 FormerlySerializedAs 어트리뷰트를 이용해 기존 버전과의 호환성을 유지해 줄 수 있다.

>> 스탯 툴팁에서 변경된 값과 이름은 출력 성공
>> 각 스탯의 설명만 추가하면 구현 완료.

========================================================================
3/20

박스에서 아이템이 랜덤으로 드롭되는 기능 구현 예정

AssetDatabase 사용
>> Unity Editor상에서 모든 에셋 관련 파일 처리를 할때 사용하는 클래스로 기본 파일 입출력부터 Material,      Prefab, Animationclip, CustomAsset등 파일을 만들고 제어 할 수 있습니다.
>> 응용으로 프로젝트 내의 모든 씬파일을 찾아서 수정을 하거나, 현재 씬에 존재하는 오브젝트들을 자동으로      프리팹으로 만들어주는 기능을 만들 수 있습니다.
>> 주의할 점은 AssetDatabase클래스는 Editor상에서만 동작하며 해당 코드를 사용하는 부분은 		     #if UNITY_EDITOR 조건 컴파일을 걸어야 빌드할 때 에러나지 않습니다.

아이템을 바닥에 드롭하면 제거되는 기능 구현